{
  "version": 3,
  "sources": ["../src/index.ts", "../src/types/config.ts", "../src/utils/config-loader.ts", "../src/utils/logger.ts", "../src/github/client.ts", "../src/utils/diff-parser.ts", "../src/utils/ast-analyzer.ts", "../src/utils/test-target-extractor.ts", "../src/llm/providers/base.ts", "../src/llm/providers/openai.ts", "../src/llm/providers/anthropic.ts", "../src/llm/providers/google.ts", "../src/llm/factory.ts", "../src/llm/prompts/test-generation.ts", "../src/llm/prompts/test-fix.ts", "../src/llm/parser.ts", "../src/llm/test-generator.ts"],
  "sourcesContent": ["// Configuration types and schema\nexport type { KakarotConfig, PartialKakarotConfig } from './types/config.js';\nexport { KakarotConfigSchema } from './types/config.js';\n\n// Config loader\nexport { loadConfig } from './utils/config-loader.js';\n\n// Logger utilities\nexport {\n  initLogger,\n  info,\n  debug,\n  warn,\n  error,\n  success,\n  progress,\n} from './utils/logger.js';\n\n// GitHub integration\nexport { GitHubClient } from './github/client.js';\nexport type {\n  PullRequest,\n  PullRequestFile,\n  FileContents,\n  CommitFile,\n  BatchCommitOptions,\n  GitHubClientOptions,\n} from './types/github.js';\n\n// Diff analysis and AST extraction\nexport { parsePullRequestFiles, getChangedRanges } from './utils/diff-parser.js';\nexport { analyzeFile } from './utils/ast-analyzer.js';\nexport { extractTestTargets } from './utils/test-target-extractor.js';\nexport type {\n  DiffHunk,\n  FileDiff,\n  ChangedRange,\n  TestTarget,\n} from './types/diff.js';\n\n// LLM integration\nexport { TestGenerator } from './llm/test-generator.js';\nexport { createLLMProvider } from './llm/factory.js';\nexport { parseTestCode, validateTestCodeStructure } from './llm/parser.js';\nexport { buildTestGenerationPrompt } from './llm/prompts/test-generation.js';\nexport { buildTestFixPrompt } from './llm/prompts/test-fix.js';\nexport type {\n  LLMMessage,\n  LLMResponse,\n  LLMProvider,\n  LLMGenerateOptions,\n  TestGenerationContext,\n  TestGenerationResult,\n  TestFixContext,\n} from './types/llm.js';\n\n", "import { z } from 'zod';\n\nexport const KakarotConfigSchema = z.object({\n  apiKey: z.string(),\n  githubToken: z.string().optional(),\n  provider: z.enum(['openai', 'anthropic', 'google']).optional(),\n  model: z.string().optional(),\n  maxTokens: z.number().int().min(1).max(100000).optional(),\n  temperature: z.number().min(0).max(2).optional(),\n  fixTemperature: z.number().min(0).max(2).optional(),\n  maxFixAttempts: z.number().int().min(0).max(5).default(3),\n  testLocation: z.enum(['separate', 'co-located']).default('separate'),\n  testDirectory: z.string().default('__tests__'),\n  testFilePattern: z.string().default('*.test.ts'),\n  includePatterns: z.array(z.string()).default(['**/*.ts', '**/*.tsx', '**/*.js', '**/*.jsx']),\n  excludePatterns: z.array(z.string()).default(['**/*.test.ts', '**/*.spec.ts', '**/*.test.js', '**/*.spec.js', '**/node_modules/**']),\n  maxTestsPerPR: z.number().int().min(1).default(50),\n  enableAutoCommit: z.boolean().default(true),\n  commitStrategy: z.enum(['direct', 'branch-pr']).default('direct'),\n  enablePRComments: z.boolean().default(true),\n  debug: z.boolean().default(false),\n});\n\nexport type KakarotConfig = z.infer<typeof KakarotConfigSchema>;\n\nexport type PartialKakarotConfig = Partial<KakarotConfig>;\n\n", "import { existsSync, readFileSync } from 'fs';\nimport { join, dirname } from 'path';\nimport { KakarotConfigSchema, type KakarotConfig, type PartialKakarotConfig } from '../types/config.js';\nimport { error } from './logger.js';\n\n/**\n * Find the project root by walking up the directory tree until package.json is found\n */\nfunction findProjectRoot(startPath?: string): string {\n  const start = startPath ?? process.cwd();\n  let current = start;\n  let previous: string | null = null;\n\n  // Walk up until we find package.json or hit filesystem root\n  while (current !== previous) {\n    if (existsSync(join(current, 'package.json'))) {\n      return current;\n    }\n    previous = current;\n    current = dirname(current);\n  }\n\n  return start;\n}\n\n/**\n * Load config from kakarot.config.ts\n */\nasync function loadTypeScriptConfig(root: string): Promise<PartialKakarotConfig | null> {\n  const configPath = join(root, 'kakarot.config.ts');\n  \n  if (!existsSync(configPath)) {\n    return null;\n  }\n\n  try {\n    // Dynamic import for TypeScript config file\n    // Note: This requires the file to be transpiled or use tsx/ts-node in runtime\n    // For now, we'll attempt to import it directly\n    const configModule = await import(configPath);\n    return configModule.default || configModule.config || null;\n  } catch (err) {\n    error(`Failed to load kakarot.config.ts: ${err instanceof Error ? err.message : String(err)}`);\n    return null;\n  }\n}\n\n/**\n * Load config from .kakarot-ci.config.js\n */\nasync function loadJavaScriptConfig(root: string): Promise<PartialKakarotConfig | null> {\n  const configPath = join(root, '.kakarot-ci.config.js');\n  \n  if (!existsSync(configPath)) {\n    return null;\n  }\n\n  try {\n    const configModule = await import(configPath);\n    return configModule.default || configModule.config || null;\n  } catch (err) {\n    error(`Failed to load .kakarot-ci.config.js: ${err instanceof Error ? err.message : String(err)}`);\n    return null;\n  }\n}\n\n/**\n * Load config from .kakarot-ci.config.json\n */\nfunction loadJsonConfig(root: string): PartialKakarotConfig | null {\n  const configPath = join(root, '.kakarot-ci.config.json');\n  \n  if (!existsSync(configPath)) {\n    return null;\n  }\n\n  try {\n    const content = readFileSync(configPath, 'utf-8');\n    return JSON.parse(content) as PartialKakarotConfig;\n  } catch (err) {\n    error(`Failed to load .kakarot-ci.config.json: ${err instanceof Error ? err.message : String(err)}`);\n    return null;\n  }\n}\n\n/**\n * Load config from package.json \u2192 kakarotCi field\n */\nfunction loadPackageJsonConfig(root: string): PartialKakarotConfig | null {\n  const packagePath = join(root, 'package.json');\n  \n  if (!existsSync(packagePath)) {\n    return null;\n  }\n\n  try {\n    const content = readFileSync(packagePath, 'utf-8');\n    const pkg = JSON.parse(content) as { kakarotCi?: PartialKakarotConfig };\n    return pkg.kakarotCi || null;\n  } catch (err) {\n    error(`Failed to load package.json: ${err instanceof Error ? err.message : String(err)}`);\n    return null;\n  }\n}\n\n/**\n * Merge environment variables with loaded config\n */\nfunction mergeEnvConfig(config: PartialKakarotConfig): PartialKakarotConfig {\n  const merged = { ...config };\n\n  // Load apiKey from environment if not in config\n  if (!merged.apiKey && process.env.KAKAROT_API_KEY) {\n    merged.apiKey = process.env.KAKAROT_API_KEY;\n  }\n\n  // Load githubToken from environment if not in config\n  if (!merged.githubToken && process.env.GITHUB_TOKEN) {\n    merged.githubToken = process.env.GITHUB_TOKEN;\n  }\n\n  return merged;\n}\n\n/**\n * Load and validate Kakarot configuration\n */\nexport async function loadConfig(): Promise<KakarotConfig> {\n  const projectRoot = findProjectRoot();\n  let config: PartialKakarotConfig | null = null;\n\n  config = await loadTypeScriptConfig(projectRoot);\n  if (config) {\n    return KakarotConfigSchema.parse(mergeEnvConfig(config));\n  }\n\n  config = await loadJavaScriptConfig(projectRoot);\n  if (config) {\n    return KakarotConfigSchema.parse(mergeEnvConfig(config));\n  }\n\n  config = loadJsonConfig(projectRoot);\n  if (config) {\n    return KakarotConfigSchema.parse(mergeEnvConfig(config));\n  }\n\n  config = loadPackageJsonConfig(projectRoot);\n  if (config) {\n    return KakarotConfigSchema.parse(mergeEnvConfig(config));\n  }\n\n  // No config found, try to load from environment only\n  const envConfig = mergeEnvConfig({});\n  try {\n    return KakarotConfigSchema.parse(envConfig);\n  } catch (err) {\n    error(\n      'Missing required apiKey. Provide it via:\\n' +\n      '  - Config file (kakarot.config.ts, .kakarot-ci.config.js/json, or package.json)\\n' +\n      '  - Environment variable: KAKAROT_API_KEY'\n    );\n    throw err;\n  }\n}\n", "import type { KakarotConfig } from '../types/config.js';\n\nlet debugMode = false;\nlet jsonMode = false;\n\nexport function initLogger(config: Pick<KakarotConfig, 'debug'>): void {\n  debugMode = config.debug ?? process.env.KAKAROT_DEBUG === 'true';\n  jsonMode = process.env.KAKAROT_OUTPUT === 'json';\n}\n\n\nexport function info(message: string, ...args: unknown[]): void {\n  if (jsonMode) {\n    console.log(JSON.stringify({ level: 'info', message, ...args }));\n  } else {\n    console.log(`[kakarot-ci] ${message}`, ...args);\n  }\n}\n\nexport function debug(message: string, ...args: unknown[]): void {\n  if (debugMode) {\n    if (jsonMode) {\n      console.debug(JSON.stringify({ level: 'debug', message, ...args }));\n    } else {\n      console.debug(`[kakarot-ci:debug] ${message}`, ...args);\n    }\n  }\n}\n\nexport function warn(message: string, ...args: unknown[]): void {\n  if (jsonMode) {\n    console.warn(JSON.stringify({ level: 'warn', message, ...args }));\n  } else {\n    console.warn(`[kakarot-ci] \u26A0 ${message}`, ...args);\n  }\n}\n\nexport function error(message: string, ...args: unknown[]): void {\n  if (jsonMode) {\n    console.error(JSON.stringify({ level: 'error', message, ...args }));\n  } else {\n    console.error(`[kakarot-ci] \u2717 ${message}`, ...args);\n  }\n}\n\nexport function success(message: string, ...args: unknown[]): void {\n  if (jsonMode) {\n    console.log(JSON.stringify({ level: 'success', message, ...args }));\n  } else {\n    console.log(`[kakarot-ci] \u2713 ${message}`, ...args);\n  }\n}\n\nexport function progress(step: number, total: number, message: string, ...args: unknown[]): void {\n  if (jsonMode) {\n    console.log(JSON.stringify({ level: 'info', step, total, message, ...args }));\n  } else {\n    console.log(`[kakarot-ci] Step ${step}/${total}: ${message}`, ...args);\n  }\n}\n", "import { Octokit } from '@octokit/rest';\nimport type { PullRequest, PullRequestFile, FileContents, GitHubClientOptions, BatchCommitOptions } from '../types/github.js';\nimport { debug, error, warn } from '../utils/logger.js';\n\n/**\n * GitHub API client wrapper with retry and rate-limit handling\n */\nexport class GitHubClient {\n  private octokit: Octokit;\n  private owner: string;\n  private repo: string;\n  private maxRetries = 3;\n  private retryDelay = 1000; // 1 second\n\n  constructor(options: GitHubClientOptions) {\n    this.owner = options.owner;\n    this.repo = options.repo;\n    this.octokit = new Octokit({\n      auth: options.token,\n      request: {\n        retries: this.maxRetries,\n        retryAfter: this.retryDelay / 1000,\n      },\n    });\n  }\n\n  /**\n   * Retry wrapper with exponential backoff\n   */\n  private async withRetry<T>(\n    fn: () => Promise<T>,\n    operation: string,\n    retries = this.maxRetries\n  ): Promise<T> {\n    try {\n      return await fn();\n    } catch (err) {\n      if (retries <= 0) {\n        error(`${operation} failed after ${this.maxRetries} retries: ${err instanceof Error ? err.message : String(err)}`);\n        throw err;\n      }\n\n      const isRateLimit = err instanceof Error && err.message.includes('rate limit');\n      const isServerError = err instanceof Error && (\n        err.message.includes('500') ||\n        err.message.includes('502') ||\n        err.message.includes('503') ||\n        err.message.includes('504')\n      );\n\n      if (isRateLimit || isServerError) {\n        const delay = this.retryDelay * Math.pow(2, this.maxRetries - retries);\n        warn(`${operation} failed, retrying in ${delay}ms... (${retries} retries left)`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.withRetry(fn, operation, retries - 1);\n      }\n\n      throw err;\n    }\n  }\n\n  /**\n   * Get pull request details\n   */\n  async getPullRequest(prNumber: number): Promise<PullRequest> {\n    return this.withRetry(async () => {\n      debug(`Fetching PR #${prNumber}`);\n      const response = await this.octokit.rest.pulls.get({\n        owner: this.owner,\n        repo: this.repo,\n        pull_number: prNumber,\n      });\n      return response.data as PullRequest;\n    }, `getPullRequest(${prNumber})`);\n  }\n\n  /**\n   * List all files changed in a pull request with patches\n   */\n  async listPullRequestFiles(prNumber: number): Promise<PullRequestFile[]> {\n    return this.withRetry(async () => {\n      debug(`Fetching files for PR #${prNumber}`);\n      const response = await this.octokit.rest.pulls.listFiles({\n        owner: this.owner,\n        repo: this.repo,\n        pull_number: prNumber,\n      });\n      return response.data.map(file => ({\n        filename: file.filename,\n        status: file.status as PullRequestFile['status'],\n        additions: file.additions,\n        deletions: file.deletions,\n        changes: file.changes,\n        patch: file.patch || undefined,\n        previous_filename: file.previous_filename || undefined,\n      }));\n    }, `listPullRequestFiles(${prNumber})`);\n  }\n\n  /**\n   * Get file contents from a specific ref (branch, commit, etc.)\n   */\n  async getFileContents(ref: string, path: string): Promise<FileContents> {\n    return this.withRetry(async () => {\n      debug(`Fetching file contents: ${path}@${ref}`);\n      const response = await this.octokit.rest.repos.getContent({\n        owner: this.owner,\n        repo: this.repo,\n        path,\n        ref,\n      });\n\n      if (Array.isArray(response.data)) {\n        throw new Error(`Expected file but got directory: ${path}`);\n      }\n\n      const data = response.data as { content: string; encoding: string; sha: string; size: number };\n      \n      // Decode base64 content\n      let content: string;\n      if (data.encoding === 'base64') {\n        content = Buffer.from(data.content, 'base64').toString('utf-8');\n      } else {\n        content = data.content;\n      }\n\n      return {\n        content,\n        encoding: data.encoding as 'base64' | 'utf-8',\n        sha: data.sha,\n        size: data.size,\n      };\n    }, `getFileContents(${ref}, ${path})`);\n  }\n\n  /**\n   * Commit multiple files in a single commit using Git tree API\n   */\n  async commitFiles(options: BatchCommitOptions): Promise<string> {\n    return this.withRetry(async () => {\n      debug(`Committing ${options.files.length} file(s) to branch ${options.branch}`);\n\n      // Get the base tree SHA\n      const baseCommit = await this.octokit.rest.repos.getCommit({\n        owner: this.owner,\n        repo: this.repo,\n        ref: options.baseSha,\n      });\n      const baseTreeSha = baseCommit.data.commit.tree.sha;\n\n      // Create blobs for all files\n      const blobPromises = options.files.map(async (file) => {\n        const blobResponse = await this.octokit.rest.git.createBlob({\n          owner: this.owner,\n          repo: this.repo,\n          content: Buffer.from(file.content, 'utf-8').toString('base64'),\n          encoding: 'base64',\n        });\n        return {\n          path: file.path,\n          sha: blobResponse.data.sha,\n          mode: '100644' as const,\n          type: 'blob' as const,\n        };\n      });\n\n      const treeItems = await Promise.all(blobPromises);\n\n      // Create a new tree with the blobs\n      const treeResponse = await this.octokit.rest.git.createTree({\n        owner: this.owner,\n        repo: this.repo,\n        base_tree: baseTreeSha,\n        tree: treeItems,\n      });\n\n      // Create the commit\n      const commitResponse = await this.octokit.rest.git.createCommit({\n        owner: this.owner,\n        repo: this.repo,\n        message: options.message,\n        tree: treeResponse.data.sha,\n        parents: [options.baseSha],\n      });\n\n      // Update the branch reference\n      await this.octokit.rest.git.updateRef({\n        owner: this.owner,\n        repo: this.repo,\n        ref: `heads/${options.branch}`,\n        sha: commitResponse.data.sha,\n      });\n\n      return commitResponse.data.sha;\n    }, `commitFiles(${options.files.length} files)`);\n  }\n\n  /**\n   * Create a new branch from a base ref\n   */\n  async createBranch(branchName: string, baseRef: string): Promise<string> {\n    return this.withRetry(async () => {\n      debug(`Creating branch ${branchName} from ${baseRef}`);\n\n      // Get the SHA of the base ref\n      const baseRefResponse = await this.octokit.rest.git.getRef({\n        owner: this.owner,\n        repo: this.repo,\n        ref: baseRef.startsWith('refs/') ? baseRef : `heads/${baseRef}`,\n      });\n      const baseSha = baseRefResponse.data.object.sha;\n\n      // Create the new branch\n      await this.octokit.rest.git.createRef({\n        owner: this.owner,\n        repo: this.repo,\n        ref: `refs/heads/${branchName}`,\n        sha: baseSha,\n      });\n\n      return baseSha;\n    }, `createBranch(${branchName})`);\n  }\n\n  /**\n   * Create a pull request\n   */\n  async createPullRequest(\n    title: string,\n    body: string,\n    head: string,\n    base: string\n  ): Promise<PullRequest> {\n    return this.withRetry(async () => {\n      debug(`Creating PR: ${head} -> ${base}`);\n\n      const response = await this.octokit.rest.pulls.create({\n        owner: this.owner,\n        repo: this.repo,\n        title,\n        body,\n        head,\n        base,\n      });\n\n      return response.data as PullRequest;\n    }, `createPullRequest(${head} -> ${base})`);\n  }\n\n  /**\n   * Post a comment on a pull request\n   */\n  async commentPR(prNumber: number, body: string): Promise<void> {\n    await this.withRetry(async () => {\n      debug(`Posting comment on PR #${prNumber}`);\n      await this.octokit.rest.issues.createComment({\n        owner: this.owner,\n        repo: this.repo,\n        issue_number: prNumber,\n        body,\n      });\n    }, `commentPR(${prNumber})`);\n  }\n\n  /**\n   * Check if a file exists in the repository\n   */\n  async fileExists(ref: string, path: string): Promise<boolean> {\n    return this.withRetry(async () => {\n      try {\n        await this.octokit.rest.repos.getContent({\n          owner: this.owner,\n          repo: this.repo,\n          path,\n          ref,\n        });\n        return true;\n      } catch (err) {\n        if (err instanceof Error && err.message.includes('404')) {\n          return false;\n        }\n        throw err;\n      }\n    }, `fileExists(${ref}, ${path})`);\n  }\n\n  /**\n   * Get the current rate limit status\n   */\n  async getRateLimit(): Promise<{ remaining: number; reset: number }> {\n    const response = await this.octokit.rest.rateLimit.get();\n    return {\n      remaining: response.data.rate.remaining,\n      reset: response.data.rate.reset,\n    };\n  }\n}\n\n", "import type { PullRequestFile } from '../types/github.js';\nimport type { FileDiff, DiffHunk } from '../types/diff.js';\nimport { debug } from './logger.js';\n\n/**\n * Parse unified diff format from GitHub patch\n */\nfunction parseUnifiedDiff(patch: string): DiffHunk[] {\n  const hunks: DiffHunk[] = [];\n  const lines = patch.split('\\n');\n  \n  let i = 0;\n  while (i < lines.length) {\n    const line = lines[i];\n    \n    // Match hunk header: @@ -oldStart,oldLines +newStart,newLines @@\n    const hunkMatch = line.match(/^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    if (hunkMatch) {\n      const oldStart = parseInt(hunkMatch[1], 10);\n      const oldLines = parseInt(hunkMatch[2] || '1', 10);\n      const newStart = parseInt(hunkMatch[3], 10);\n      const newLines = parseInt(hunkMatch[4] || '1', 10);\n      \n      const hunkLines: string[] = [];\n      i++;\n      \n      // Collect lines until next hunk or end\n      while (i < lines.length && !lines[i].startsWith('@@')) {\n        hunkLines.push(lines[i]);\n        i++;\n      }\n      \n      hunks.push({\n        oldStart,\n        oldLines,\n        newStart,\n        newLines,\n        lines: hunkLines,\n      });\n    } else {\n      i++;\n    }\n  }\n  \n  return hunks;\n}\n\n/**\n * Convert diff hunks to changed line ranges\n * \n * Note: We're additions-first for test generation - we generate tests for new/modified code.\n * Deletions are tracked but primarily used for context. Merged ranges represent \"fuzzy zones\"\n * of change rather than exact line-by-line mappings, which helps with function-level detection.\n */\nfunction hunksToChangedRanges(hunks: DiffHunk[]): Array<{ start: number; end: number; type: 'addition' | 'deletion' }> {\n  const ranges: Array<{ start: number; end: number; type: 'addition' | 'deletion' }> = [];\n  \n  for (const hunk of hunks) {\n    let oldLine = hunk.oldStart;\n    let newLine = hunk.newStart;\n    \n    for (const line of hunk.lines) {\n      if (line.startsWith('+') && !line.startsWith('+++')) {\n        // Addition - these are the lines we care about for test generation\n        ranges.push({\n          start: newLine,\n          end: newLine,\n          type: 'addition',\n        });\n        newLine++;\n      } else if (line.startsWith('-') && !line.startsWith('---')) {\n        // Deletion - tracked for context, but additions are primary for test targets\n        ranges.push({\n          start: oldLine,\n          end: oldLine,\n          type: 'deletion',\n        });\n        oldLine++;\n      } else if (!line.startsWith('\\\\')) {\n        // Context line (unchanged)\n        oldLine++;\n        newLine++;\n      }\n    }\n  }\n  \n  // Merge adjacent ranges (creates \"fuzzy zones\" of change)\n  return mergeRanges(ranges);\n}\n\n/**\n * Merge adjacent or overlapping ranges\n * \n * Creates \"fuzzy zones\" of change - merged ranges represent approximate areas where\n * changes occurred, not exact line-by-line mappings. This helps with function-level\n * detection where we want to catch functions that are near changes.\n */\nfunction mergeRanges(\n  ranges: Array<{ start: number; end: number; type: 'addition' | 'deletion' }>\n): Array<{ start: number; end: number; type: 'addition' | 'deletion' }> {\n  if (ranges.length === 0) return [];\n  \n  const sorted = [...ranges].sort((a, b) => a.start - b.start);\n  const merged: Array<{ start: number; end: number; type: 'addition' | 'deletion' }> = [];\n  \n  let current = sorted[0];\n  \n  for (let i = 1; i < sorted.length; i++) {\n    const next = sorted[i];\n    \n    // If ranges overlap or are adjacent (within 2 lines), merge them\n    if (next.start <= current.end + 2 && next.type === current.type) {\n      current = {\n        start: current.start,\n        end: Math.max(current.end, next.end),\n        type: current.type,\n      };\n    } else {\n      merged.push(current);\n      current = next;\n    }\n  }\n  \n  merged.push(current);\n  return merged;\n}\n\n/**\n * Parse PR files into structured diff format\n */\nexport function parsePullRequestFiles(files: PullRequestFile[]): FileDiff[] {\n  const diffs: FileDiff[] = [];\n  \n  for (const file of files) {\n    // Filter TypeScript and JavaScript files\n    if (!file.filename.match(/\\.(ts|tsx|js|jsx)$/)) {\n      continue;\n    }\n    \n    if (!file.patch) {\n      // File was added or removed without patch\n      diffs.push({\n        filename: file.filename,\n        status: file.status as FileDiff['status'],\n        hunks: [],\n        additions: file.additions,\n        deletions: file.deletions,\n      });\n      continue;\n    }\n    \n    const hunks = parseUnifiedDiff(file.patch);\n    \n    diffs.push({\n      filename: file.filename,\n      status: file.status as FileDiff['status'],\n      hunks,\n      additions: file.additions,\n      deletions: file.deletions,\n    });\n    \n    debug(`Parsed ${hunks.length} hunk(s) for ${file.filename}`);\n  }\n  \n  return diffs;\n}\n\n/**\n * Get changed line ranges for a file diff\n * \n * For added files: Requires fileContent to determine line count. Returns ranges\n * covering the entire file (all lines are additions in new files).\n * \n * For removed files: Returns empty (nothing to test in deleted files).\n * \n * For modified files: Returns merged ranges representing fuzzy zones of change.\n * Note: Deletion ranges use OLD file line numbers and should only be used for\n * metadata/context, not for overlap detection in the new file.\n */\nexport function getChangedRanges(\n  diff: FileDiff,\n  fileContent?: string\n): Array<{ start: number; end: number; type: 'addition' | 'deletion' }> {\n  if (diff.status === 'added') {\n    if (!fileContent) {\n      throw new Error('fileContent is required for added files to determine line count');\n    }\n    // For new files, entire file is changed (all lines are additions)\n    const lineCount = fileContent.split('\\n').length;\n    return [{ start: 1, end: lineCount, type: 'addition' }];\n  }\n  \n  if (diff.status === 'removed') {\n    // For removed files, return empty (nothing to test)\n    return [];\n  }\n  \n  return hunksToChangedRanges(diff.hunks);\n}\n\n", "import * as ts from 'typescript';\nimport type { ChangedRange, TestTarget } from '../types/diff.js';\nimport { debug } from './logger.js';\n\ninterface FunctionNode {\n  name: string;\n  type: 'function' | 'method' | 'arrow-function' | 'class-method';\n  start: number;\n  end: number;\n  node: ts.Node;\n}\n\n/**\n * Extract functions/methods from TypeScript source code\n */\nfunction extractFunctions(sourceFile: ts.SourceFile): FunctionNode[] {\n  const functions: FunctionNode[] = [];\n  \n  function visit(node: ts.Node) {\n    // Function declarations (including export default)\n    if (ts.isFunctionDeclaration(node)) {\n      // Check if it's exported (export function foo() {} or export default function foo() {})\n      const isExported = node.modifiers?.some(m => \n        m.kind === ts.SyntaxKind.ExportKeyword || m.kind === ts.SyntaxKind.DefaultKeyword\n      );\n      \n      if (node.name) {\n        functions.push({\n          name: node.name.text,\n          type: 'function',\n          start: node.getStart(sourceFile),\n          end: node.getEnd(),\n          node,\n        });\n      } else if (isExported) {\n        // Anonymous export default function: export default function () {}\n        functions.push({\n          name: 'default',\n          type: 'function',\n          start: node.getStart(sourceFile),\n          end: node.getEnd(),\n          node,\n        });\n      }\n    }\n    \n    // Export default with function expressions: export default (function foo() {})\n    // Note: FunctionDeclarations with export default are handled above via modifiers\n    if (ts.isExportAssignment(node) && node.isExportEquals === false && ts.isFunctionExpression(node.expression)) {\n      const func = node.expression;\n      const name = func.name ? func.name.text : 'default';\n      functions.push({\n        name,\n        type: 'function',\n        start: node.getStart(sourceFile),\n        end: node.getEnd(),\n        node,\n      });\n    }\n    \n    // Method declarations (class methods)\n    if (ts.isMethodDeclaration(node) && node.name && ts.isIdentifier(node.name)) {\n      functions.push({\n        name: node.name.text,\n        type: 'class-method',\n        start: node.getStart(sourceFile),\n        end: node.getEnd(),\n        node,\n      });\n    }\n    \n    // Variable statements: const foo = function() {} or const foo = function bar() {}\n    if (ts.isVariableStatement(node)) {\n      for (const declaration of node.declarationList.declarations) {\n        if (declaration.initializer) {\n          // Arrow functions\n          if (ts.isArrowFunction(declaration.initializer)) {\n            if (ts.isIdentifier(declaration.name)) {\n              functions.push({\n                name: declaration.name.text,\n                type: 'arrow-function',\n                start: declaration.getStart(sourceFile),\n                end: declaration.getEnd(),\n                node: declaration,\n              });\n            }\n          }\n          // Named function expressions: const foo = function bar() {}\n          else if (ts.isFunctionExpression(declaration.initializer)) {\n            const funcExpr = declaration.initializer;\n            // Use the function name if it has one, otherwise use the variable name\n            const name = funcExpr.name\n              ? funcExpr.name.text\n              : ts.isIdentifier(declaration.name)\n              ? declaration.name.text\n              : 'anonymous';\n            \n            if (name !== 'anonymous') {\n              functions.push({\n                name,\n                type: 'function',\n                start: declaration.getStart(sourceFile),\n                end: declaration.getEnd(),\n                node: declaration,\n              });\n            }\n          }\n        }\n      }\n    }\n    \n    // Object method shorthand\n    if (ts.isPropertyAssignment(node) && ts.isIdentifier(node.name)) {\n      if (ts.isFunctionExpression(node.initializer) || ts.isArrowFunction(node.initializer)) {\n        functions.push({\n          name: node.name.text,\n          type: 'method',\n          start: node.getStart(sourceFile),\n          end: node.getEnd(),\n          node,\n        });\n      }\n    }\n    \n    ts.forEachChild(node, visit);\n  }\n  \n  visit(sourceFile);\n  return functions;\n}\n\n/**\n * Get line number from character position\n * \n * Note: For performance, consider caching line start positions if called\n * repeatedly on the same source. TypeScript's SourceFile.getLineAndCharacterOfPosition\n * could be used as an alternative.\n */\nfunction getLineNumber(source: string, position: number): number {\n  return source.substring(0, position).split('\\n').length;\n}\n\n/**\n * Check if a function overlaps with changed ranges\n * \n * Note: Only uses 'addition' ranges for overlap detection. Deletion ranges\n * use OLD file line numbers and don't map to the new file, so they're\n * excluded from overlap checks (but kept in metadata).\n */\nfunction functionOverlapsChanges(\n  func: FunctionNode,\n  changedRanges: ChangedRange[],\n  source: string\n): boolean {\n  const funcStartLine = getLineNumber(source, func.start);\n  const funcEndLine = getLineNumber(source, func.end);\n  \n  // Only check addition ranges - deletions use old file line numbers\n  const additionRanges = changedRanges.filter(r => r.type === 'addition');\n  \n  for (const range of additionRanges) {\n    // Check if changed range overlaps with function\n    if (\n      (range.start >= funcStartLine && range.start <= funcEndLine) ||\n      (range.end >= funcStartLine && range.end <= funcEndLine) ||\n      (range.start <= funcStartLine && range.end >= funcEndLine)\n    ) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\n/**\n * Extract code snippet for a function\n */\nfunction extractCodeSnippet(source: string, func: FunctionNode): string {\n  return source.substring(func.start, func.end);\n}\n\n/**\n * Extract minimal context around a function (previous function + next few lines)\n */\nfunction extractContext(source: string, func: FunctionNode, allFunctions: FunctionNode[]): string {\n  const funcStartLine = getLineNumber(source, func.start);\n  const funcEndLine = getLineNumber(source, func.end);\n  \n  // Find previous function\n  const previousFunc = allFunctions\n    .filter(f => getLineNumber(source, f.end) < funcStartLine)\n    .sort((a, b) => getLineNumber(source, b.end) - getLineNumber(source, a.end))[0];\n  \n  const contextStart = previousFunc\n    ? getLineNumber(source, previousFunc.start)\n    : Math.max(1, funcStartLine - 10);\n  \n  const lines = source.split('\\n');\n  const contextLines = lines.slice(contextStart - 1, funcEndLine + 5);\n  \n  return contextLines.join('\\n');\n}\n\n/**\n * Detect existing test file for a source file by actually checking the repository\n */\nasync function detectTestFile(\n  filePath: string,\n  ref: string,\n  githubClient: { fileExists: (ref: string, path: string) => Promise<boolean> },\n  testDirectory: string\n): Promise<string | undefined> {\n  const dir = filePath.substring(0, filePath.lastIndexOf('/'));\n  const baseName = filePath.substring(filePath.lastIndexOf('/') + 1).replace(/\\.(ts|tsx|js|jsx)$/, '');\n  \n  // Determine file extension and corresponding test patterns\n  let ext: 'ts' | 'tsx' | 'js' | 'jsx';\n  if (filePath.endsWith('.tsx')) ext = 'tsx';\n  else if (filePath.endsWith('.jsx')) ext = 'jsx';\n  else if (filePath.endsWith('.ts')) ext = 'ts';\n  else ext = 'js';\n  \n  // Test file patterns to check (match source file type)\n  const testPatterns = \n    ext === 'tsx' ? [`.test.tsx`, `.spec.tsx`, `.test.ts`, `.spec.ts`] :\n    ext === 'jsx' ? [`.test.jsx`, `.spec.jsx`, `.test.js`, `.spec.js`] :\n    ext === 'ts' ? [`.test.ts`, `.spec.ts`] :\n    [`.test.js`, `.spec.js`];\n  \n  // Locations to check (in order of preference, deduplicated)\n  const locations = [\n    // Co-located in same directory\n    ...testPatterns.map(pattern => `${dir}/${baseName}${pattern}`),\n    // Co-located __tests__ directory\n    ...testPatterns.map(pattern => `${dir}/__tests__/${baseName}${pattern}`),\n    // Test directory at root\n    ...testPatterns.map(pattern => `${testDirectory}/${baseName}${pattern}`),\n    // Nested test directory matching source structure\n    ...testPatterns.map(pattern => `${testDirectory}${dir}/${baseName}${pattern}`),\n    // __tests__ at root\n    ...testPatterns.map(pattern => `__tests__/${baseName}${pattern}`),\n  ];\n  \n  // Check each location to see if file actually exists\n  for (const testPath of locations) {\n    const exists = await githubClient.fileExists(ref, testPath);\n    if (exists) {\n      return testPath;\n    }\n  }\n  \n  return undefined;\n}\n\n/**\n * Analyze TypeScript file and extract test targets\n */\nexport async function analyzeFile(\n  filePath: string,\n  content: string,\n  changedRanges: ChangedRange[],\n  ref: string,\n  githubClient: { fileExists: (ref: string, path: string) => Promise<boolean> },\n  testDirectory: string\n): Promise<TestTarget[]> {\n  const sourceFile = ts.createSourceFile(\n    filePath,\n    content,\n    ts.ScriptTarget.Latest,\n    true\n  );\n  \n  const functions = extractFunctions(sourceFile);\n  \n  // Check for existing test file once per file (not per function)\n  const existingTestFile = await detectTestFile(filePath, ref, githubClient, testDirectory);\n  \n  const targets: TestTarget[] = [];\n  \n  for (const func of functions) {\n    if (functionOverlapsChanges(func, changedRanges, content)) {\n      const startLine = getLineNumber(content, func.start);\n      const endLine = getLineNumber(content, func.end);\n      \n      targets.push({\n        filePath,\n        functionName: func.name,\n        functionType: func.type,\n        startLine,\n        endLine,\n        code: extractCodeSnippet(content, func),\n        context: extractContext(content, func, functions),\n        existingTestFile,\n        changedRanges: changedRanges.filter(\n          r => r.start >= startLine && r.end <= endLine\n        ),\n      });\n      \n      debug(`Found test target: ${func.name} (${func.type}) in ${filePath}${existingTestFile ? ` - existing test: ${existingTestFile}` : ''}`);\n    }\n  }\n  \n  return targets;\n}\n\n", "import type { PullRequestFile } from '../types/github.js';\nimport type { KakarotConfig } from '../types/config.js';\nimport type { TestTarget } from '../types/diff.js';\nimport { GitHubClient } from '../github/client.js';\nimport { parsePullRequestFiles, getChangedRanges } from './diff-parser.js';\nimport { analyzeFile } from './ast-analyzer.js';\nimport { debug, info } from './logger.js';\n\n/**\n * Extract test targets from pull request files\n */\nexport async function extractTestTargets(\n  files: PullRequestFile[],\n  githubClient: GitHubClient,\n  prHeadRef: string,\n  config: Pick<KakarotConfig, 'testDirectory' | 'testFilePattern' | 'includePatterns' | 'excludePatterns'>\n): Promise<TestTarget[]> {\n  info(`Analyzing ${files.length} file(s) for test targets`);\n  \n  // Parse diffs\n  const diffs = parsePullRequestFiles(files);\n  \n  // Filter by include/exclude patterns\n  const filteredDiffs = diffs.filter(diff => {\n    // Check include patterns\n    const matchesInclude = config.includePatterns.some(pattern => {\n      const regex = new RegExp(pattern.replace(/\\*\\*/g, '.*').replace(/\\*/g, '[^/]*'));\n      return regex.test(diff.filename);\n    });\n    \n    if (!matchesInclude) return false;\n    \n    // Check exclude patterns\n    const matchesExclude = config.excludePatterns.some(pattern => {\n      const regex = new RegExp(pattern.replace(/\\*\\*/g, '.*').replace(/\\*/g, '[^/]*'));\n      return regex.test(diff.filename);\n    });\n    \n    return !matchesExclude;\n  });\n  \n  debug(`Filtered to ${filteredDiffs.length} file(s) after pattern matching`);\n  \n  const targets: TestTarget[] = [];\n  \n  // Process each file\n  for (const diff of filteredDiffs) {\n    if (diff.status === 'removed') {\n      // Skip removed files\n      continue;\n    }\n    \n    try {\n      // Fetch file contents from PR head (the branch with changes)\n      const fileContents = await githubClient.getFileContents(prHeadRef, diff.filename);\n      \n      // Get changed ranges (pass fileContent for added files)\n      const changedRanges = getChangedRanges(diff, fileContents.content);\n      \n      if (changedRanges.length === 0) {\n        // No changes detected, skip\n        continue;\n      }\n      \n      // Use the detected changed ranges (getChangedRanges now handles added files)\n      const ranges = changedRanges.map(r => ({\n        start: r.start,\n        end: r.end,\n        type: r.type as 'addition' | 'deletion',\n      }));\n      \n      // Analyze AST and extract test targets (use head ref for test file detection)\n      const fileTargets = await analyzeFile(\n        diff.filename,\n        fileContents.content,\n        ranges,\n        prHeadRef,\n        githubClient,\n        config.testDirectory\n      );\n      \n      targets.push(...fileTargets);\n      \n      if (fileTargets.length > 0) {\n        info(`Found ${fileTargets.length} test target(s) in ${diff.filename}`);\n      }\n    } catch (error) {\n      debug(`Failed to analyze ${diff.filename}: ${error instanceof Error ? error.message : String(error)}`);\n      // Continue with other files\n    }\n  }\n  \n  info(`Extracted ${targets.length} total test target(s)`);\n  return targets;\n}\n\n", "/**\n * Base LLM provider interface and utilities\n */\n\nimport type { LLMMessage, LLMResponse, LLMGenerateOptions, LLMProvider } from '../../types/llm.js';\nimport { error, debug } from '../../utils/logger.js';\n\nexport abstract class BaseLLMProvider implements LLMProvider {\n  protected apiKey: string;\n  protected model: string;\n  protected defaultOptions: Required<LLMGenerateOptions>;\n\n  constructor(apiKey: string, model: string, defaultOptions?: Partial<LLMGenerateOptions>) {\n    this.apiKey = apiKey;\n    this.model = model;\n    this.defaultOptions = {\n      temperature: defaultOptions?.temperature ?? 0.2,\n      maxTokens: defaultOptions?.maxTokens ?? 4000,\n      stopSequences: defaultOptions?.stopSequences ?? [],\n    };\n  }\n\n  abstract generate(messages: LLMMessage[], options?: LLMGenerateOptions): Promise<LLMResponse>;\n\n  protected mergeOptions(options?: LLMGenerateOptions): Required<LLMGenerateOptions> {\n    return {\n      temperature: options?.temperature ?? this.defaultOptions.temperature,\n      maxTokens: options?.maxTokens ?? this.defaultOptions.maxTokens,\n      stopSequences: options?.stopSequences ?? this.defaultOptions.stopSequences,\n    };\n  }\n\n  protected validateApiKey(): void {\n    if (!this.apiKey || this.apiKey.trim().length === 0) {\n      error('LLM API key is required but not provided');\n      throw new Error('LLM API key is required');\n    }\n  }\n\n  protected logUsage(usage: LLMResponse['usage'], operation: string): void {\n    if (usage) {\n      debug(\n        `${operation} usage: ${usage.totalTokens ?? 'unknown'} tokens ` +\n          `(prompt: ${usage.promptTokens ?? 'unknown'}, completion: ${usage.completionTokens ?? 'unknown'})`\n      );\n    }\n  }\n}\n\n", "/**\n * OpenAI provider implementation\n */\n\nimport { BaseLLMProvider } from './base.js';\nimport type { LLMMessage, LLMResponse, LLMGenerateOptions } from '../../types/llm.js';\nimport { error, debug } from '../../utils/logger.js';\n\ninterface OpenAIResponse {\n  choices: Array<{\n    message: {\n      role: string;\n      content: string;\n    };\n    finish_reason: string;\n  }>;\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n}\n\nexport class OpenAIProvider extends BaseLLMProvider {\n  private baseUrl = 'https://api.openai.com/v1';\n\n  async generate(messages: LLMMessage[], options?: LLMGenerateOptions): Promise<LLMResponse> {\n    this.validateApiKey();\n    const mergedOptions = this.mergeOptions(options);\n\n    const requestBody = {\n      model: this.model,\n      messages: messages.map((msg) => ({\n        role: msg.role,\n        content: msg.content,\n      })),\n      temperature: mergedOptions.temperature,\n      max_tokens: mergedOptions.maxTokens,\n      ...(mergedOptions.stopSequences.length > 0 && { stop: mergedOptions.stopSequences }),\n    };\n\n    debug(`Calling OpenAI API with model: ${this.model}`);\n\n    try {\n      const response = await fetch(`${this.baseUrl}/chat/completions`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${this.apiKey}`,\n        },\n        body: JSON.stringify(requestBody),\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        error(`OpenAI API error: ${response.status} ${response.statusText} - ${errorText}`);\n        throw new Error(`OpenAI API error: ${response.status} ${response.statusText}`);\n      }\n\n      const data = (await response.json()) as OpenAIResponse;\n\n      if (!data.choices || data.choices.length === 0) {\n        error('OpenAI API returned no choices');\n        throw new Error('OpenAI API returned no choices');\n      }\n\n      const content = data.choices[0]?.message?.content ?? '';\n      const usage = data.usage\n        ? {\n            promptTokens: data.usage.prompt_tokens,\n            completionTokens: data.usage.completion_tokens,\n            totalTokens: data.usage.total_tokens,\n          }\n        : undefined;\n\n      this.logUsage(usage, 'OpenAI');\n\n      return {\n        content,\n        usage,\n      };\n    } catch (err) {\n      if (err instanceof Error) {\n        error(`OpenAI API request failed: ${err.message}`);\n        throw err;\n      }\n      throw new Error('Unknown error calling OpenAI API');\n    }\n  }\n}\n\n", "/**\n * Anthropic (Claude) provider implementation\n */\n\nimport { BaseLLMProvider } from './base.js';\nimport type { LLMMessage, LLMResponse, LLMGenerateOptions } from '../../types/llm.js';\nimport { error, debug } from '../../utils/logger.js';\n\ninterface AnthropicMessage {\n  role: 'user' | 'assistant';\n  content: string;\n}\n\ninterface AnthropicRequest {\n  model: string;\n  max_tokens: number;\n  temperature: number;\n  messages: AnthropicMessage[];\n  system?: string;\n  stop_sequences?: string[];\n}\n\ninterface AnthropicResponse {\n  content: Array<{\n    type: string;\n    text: string;\n  }>;\n  usage?: {\n    input_tokens: number;\n    output_tokens: number;\n  };\n}\n\nexport class AnthropicProvider extends BaseLLMProvider {\n  private baseUrl = 'https://api.anthropic.com/v1';\n\n  async generate(messages: LLMMessage[], options?: LLMGenerateOptions): Promise<LLMResponse> {\n    this.validateApiKey();\n    const mergedOptions = this.mergeOptions(options);\n\n    // Anthropic requires system message to be separate\n    const systemMessage = messages.find((m) => m.role === 'system')?.content ?? '';\n    const conversationMessages = messages.filter((m) => m.role !== 'system');\n\n    const requestBody: AnthropicRequest = {\n      model: this.model,\n      max_tokens: mergedOptions.maxTokens,\n      temperature: mergedOptions.temperature,\n      messages: conversationMessages.map((msg) => ({\n        role: msg.role === 'assistant' ? 'assistant' : 'user',\n        content: msg.content,\n      })),\n      ...(systemMessage && { system: systemMessage }),\n      ...(mergedOptions.stopSequences.length > 0 && { stop_sequences: mergedOptions.stopSequences }),\n    };\n\n    debug(`Calling Anthropic API with model: ${this.model}`);\n\n    try {\n      const response = await fetch(`${this.baseUrl}/messages`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'x-api-key': this.apiKey,\n          'anthropic-version': '2023-06-01',\n        },\n        body: JSON.stringify(requestBody),\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        error(`Anthropic API error: ${response.status} ${response.statusText} - ${errorText}`);\n        throw new Error(`Anthropic API error: ${response.status} ${response.statusText}`);\n      }\n\n      const data = (await response.json()) as AnthropicResponse;\n\n      if (!data.content || data.content.length === 0) {\n        error('Anthropic API returned no content');\n        throw new Error('Anthropic API returned no content');\n      }\n\n      const content = data.content.map((c) => c.text).join('\\n');\n      const usage = data.usage\n        ? {\n            promptTokens: data.usage.input_tokens,\n            completionTokens: data.usage.output_tokens,\n            totalTokens: data.usage.input_tokens + data.usage.output_tokens,\n          }\n        : undefined;\n\n      this.logUsage(usage, 'Anthropic');\n\n      return {\n        content,\n        usage,\n      };\n    } catch (err) {\n      if (err instanceof Error) {\n        error(`Anthropic API request failed: ${err.message}`);\n        throw err;\n      }\n      throw new Error('Unknown error calling Anthropic API');\n    }\n  }\n}\n\n", "/**\n * Google (Gemini) provider implementation\n */\n\nimport { BaseLLMProvider } from './base.js';\nimport type { LLMMessage, LLMResponse, LLMGenerateOptions } from '../../types/llm.js';\nimport { error, debug } from '../../utils/logger.js';\n\ninterface GoogleContentPart {\n  text: string;\n}\n\ninterface GoogleContent {\n  role: 'user' | 'model';\n  parts: GoogleContentPart[];\n}\n\ninterface GoogleGenerationConfig {\n  temperature: number;\n  maxOutputTokens: number;\n  stopSequences?: string[];\n}\n\ninterface GoogleSystemInstruction {\n  parts: GoogleContentPart[];\n}\n\ninterface GoogleRequest {\n  contents: GoogleContent[];\n  generationConfig: GoogleGenerationConfig;\n  systemInstruction?: GoogleSystemInstruction;\n}\n\ninterface GoogleResponse {\n  candidates: Array<{\n    content: {\n      parts: Array<{\n        text: string;\n      }>;\n    };\n    finishReason: string;\n  }>;\n  usageMetadata?: {\n    promptTokenCount: number;\n    candidatesTokenCount: number;\n    totalTokenCount: number;\n  };\n}\n\nexport class GoogleProvider extends BaseLLMProvider {\n  private baseUrl = 'https://generativelanguage.googleapis.com/v1beta';\n\n  async generate(messages: LLMMessage[], options?: LLMGenerateOptions): Promise<LLMResponse> {\n    this.validateApiKey();\n    const mergedOptions = this.mergeOptions(options);\n\n    // Google Gemini uses a different message format\n    const systemInstruction = messages.find((m) => m.role === 'system')?.content;\n    const conversationMessages = messages.filter((m) => m.role !== 'system');\n\n    const contents: GoogleContent[] = conversationMessages.map((msg) => ({\n      role: (msg.role === 'assistant' ? 'model' : 'user') as 'user' | 'model',\n      parts: [{ text: msg.content }],\n    }));\n\n    const generationConfig: GoogleGenerationConfig = {\n      temperature: mergedOptions.temperature,\n      maxOutputTokens: mergedOptions.maxTokens,\n      ...(mergedOptions.stopSequences.length > 0 && { stopSequences: mergedOptions.stopSequences }),\n    };\n\n    const requestBody: GoogleRequest = {\n      contents,\n      generationConfig,\n      ...(systemInstruction && { systemInstruction: { parts: [{ text: systemInstruction }] } }),\n    };\n\n    debug(`Calling Google API with model: ${this.model}`);\n\n    try {\n      const response = await fetch(`${this.baseUrl}/${this.model}:generateContent?key=${this.apiKey}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(requestBody),\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        error(`Google API error: ${response.status} ${response.statusText} - ${errorText}`);\n        throw new Error(`Google API error: ${response.status} ${response.statusText}`);\n      }\n\n      const data = (await response.json()) as GoogleResponse;\n\n      if (!data.candidates || data.candidates.length === 0) {\n        error('Google API returned no candidates');\n        throw new Error('Google API returned no candidates');\n      }\n\n      const content = data.candidates[0]?.content?.parts?.map((p) => p.text).join('\\n') ?? '';\n      const usage = data.usageMetadata\n        ? {\n            promptTokens: data.usageMetadata.promptTokenCount,\n            completionTokens: data.usageMetadata.candidatesTokenCount,\n            totalTokens: data.usageMetadata.totalTokenCount,\n          }\n        : undefined;\n\n      this.logUsage(usage, 'Google');\n\n      return {\n        content,\n        usage,\n      };\n    } catch (err) {\n      if (err instanceof Error) {\n        error(`Google API request failed: ${err.message}`);\n        throw err;\n      }\n      throw new Error('Unknown error calling Google API');\n    }\n  }\n}\n\n", "/**\n * LLM provider factory\n */\n\nimport type { KakarotConfig } from '../types/config.js';\nimport type { LLMProvider } from '../types/llm.js';\nimport { OpenAIProvider } from './providers/openai.js';\nimport { AnthropicProvider } from './providers/anthropic.js';\nimport { GoogleProvider } from './providers/google.js';\nimport { error } from '../utils/logger.js';\n\n/**\n * Create an LLM provider based on configuration\n */\nexport function createLLMProvider(\n  config: Pick<KakarotConfig, 'apiKey' | 'provider' | 'model' | 'maxTokens'>\n): LLMProvider {\n  const provider = config.provider ?? 'openai';\n  const model = config.model ?? getDefaultModel(provider);\n  const defaultOptions = config.maxTokens ? { maxTokens: config.maxTokens } : undefined;\n\n  switch (provider) {\n    case 'openai':\n      return new OpenAIProvider(config.apiKey, model, defaultOptions);\n    case 'anthropic':\n      return new AnthropicProvider(config.apiKey, model, defaultOptions);\n    case 'google':\n      return new GoogleProvider(config.apiKey, model, defaultOptions);\n    default:\n      error(`Unknown LLM provider: ${provider}`);\n      throw new Error(`Unknown LLM provider: ${provider}`);\n  }\n}\n\n/**\n * Get default model for a provider\n */\nfunction getDefaultModel(provider: 'openai' | 'anthropic' | 'google'): string {\n  switch (provider) {\n    case 'openai':\n      return 'gpt-4-turbo-preview';\n    case 'anthropic':\n      return 'claude-3-5-sonnet-20241022';\n    case 'google':\n      return 'gemini-1.5-pro';\n    default:\n      return 'gpt-4-turbo-preview';\n  }\n}\n\n", "/**\n * Test generation prompt builder\n */\n\nimport type { LLMMessage } from '../../types/llm.js';\nimport type { TestGenerationContext } from '../../types/llm.js';\n\nexport function buildTestGenerationPrompt(context: TestGenerationContext): LLMMessage[] {\n  const { target, framework, existingTestFile, relatedFunctions } = context;\n\n  const systemPrompt = buildSystemPrompt(framework);\n  const userPrompt = buildUserPrompt(target, framework, existingTestFile, relatedFunctions);\n\n  return [\n    { role: 'system', content: systemPrompt },\n    { role: 'user', content: userPrompt },\n  ];\n}\n\nfunction buildSystemPrompt(framework: 'jest' | 'vitest'): string {\n  const frameworkName = framework === 'jest' ? 'Jest' : 'Vitest';\n  const importStatement = framework === 'jest' ? \"import { describe, it, expect } from 'jest';\" : \"import { describe, it, expect } from 'vitest';\";\n\n  return `You are an expert ${frameworkName} test writer. Your task is to generate comprehensive unit tests for TypeScript/JavaScript functions.\n\nRequirements:\n1. Generate complete, runnable ${frameworkName} test code\n2. Use ${frameworkName} syntax and best practices\n3. Test edge cases, error conditions, and normal operation\n4. Use descriptive test names that explain what is being tested\n5. Include proper setup/teardown if needed\n6. Mock external dependencies appropriately\n7. Test both success and failure scenarios\n8. Follow the existing test file structure if one exists\n\nOutput format:\n- Return ONLY the test code, no explanations or markdown code blocks\n- The code should be ready to run in a ${frameworkName} environment\n- Include necessary imports at the top\n- Use proper TypeScript types if the source code uses TypeScript\n\n${frameworkName} example structure:\n${importStatement}\n\ndescribe('FunctionName', () => {\n  it('should handle normal case', () => {\n    // test implementation\n  });\n\n  it('should handle edge case', () => {\n    // test implementation\n  });\n});`;\n}\n\nfunction buildUserPrompt(\n  target: TestGenerationContext['target'],\n  framework: 'jest' | 'vitest',\n  existingTestFile?: string,\n  relatedFunctions?: Array<{ name: string; code: string }>\n): string {\n  let prompt = `Generate ${framework} unit tests for the following function:\\n\\n`;\n\n  prompt += `File: ${target.filePath}\\n`;\n  prompt += `Function: ${target.functionName}\\n`;\n  prompt += `Type: ${target.functionType}\\n\\n`;\n\n  prompt += `Function code:\\n\\`\\`\\`typescript\\n${target.code}\\n\\`\\`\\`\\n\\n`;\n\n  if (target.context) {\n    prompt += `Context (surrounding code):\\n\\`\\`\\`typescript\\n${target.context}\\n\\`\\`\\`\\n\\n`;\n  }\n\n  if (relatedFunctions && relatedFunctions.length > 0) {\n    prompt += `Related functions (for context):\\n`;\n    relatedFunctions.forEach((fn) => {\n      prompt += `\\n${fn.name}:\\n\\`\\`\\`typescript\\n${fn.code}\\n\\`\\`\\`\\n`;\n    });\n    prompt += '\\n';\n  }\n\n  if (existingTestFile) {\n    prompt += `Existing test file structure (follow this pattern):\\n\\`\\`\\`typescript\\n${existingTestFile}\\n\\`\\`\\`\\n\\n`;\n    prompt += `Note: Add new tests to this file, maintaining the existing structure and style.\\n\\n`;\n  }\n\n  prompt += `Generate comprehensive unit tests for ${target.functionName}. Include:\\n`;\n  prompt += `- Tests for normal operation with various inputs\\n`;\n  prompt += `- Tests for edge cases (null, undefined, empty arrays, etc.)\\n`;\n  prompt += `- Tests for error conditions if applicable\\n`;\n  prompt += `- Tests for boundary conditions\\n`;\n  prompt += `- Proper mocking of dependencies if needed\\n\\n`;\n\n  prompt += `Return ONLY the test code, no explanations or markdown formatting.`;\n\n  return prompt;\n}\n\n", "/**\n * Test fix prompt builder for fix loop\n */\n\nimport type { LLMMessage } from '../../types/llm.js';\nimport type { TestFixContext } from '../../types/llm.js';\n\nexport function buildTestFixPrompt(context: TestFixContext): LLMMessage[] {\n  const { testCode, errorMessage, testOutput, originalCode, framework, attempt, maxAttempts } = context;\n\n  const systemPrompt = buildSystemPrompt(framework, attempt, maxAttempts);\n  const userPrompt = buildUserPrompt(testCode, errorMessage, testOutput, originalCode, framework, attempt);\n\n  return [\n    { role: 'system', content: systemPrompt },\n    { role: 'user', content: userPrompt },\n  ];\n}\n\nfunction buildSystemPrompt(framework: 'jest' | 'vitest', attempt: number, maxAttempts: number): string {\n  const frameworkName = framework === 'jest' ? 'Jest' : 'Vitest';\n\n  return `You are an expert ${frameworkName} test debugger. Your task is to fix failing unit tests.\n\nContext:\n- This is fix attempt ${attempt} of ${maxAttempts}\n- The test code failed to run or produced incorrect results\n- You need to analyze the error and fix the test code\n\nRequirements:\n1. Fix the test code to make it pass\n2. Maintain the original test intent\n3. Use proper ${frameworkName} syntax\n4. Ensure all imports and dependencies are correct\n5. Fix any syntax errors, type errors, or logical errors\n6. If the original code being tested has issues, note that but focus on fixing the test\n\nOutput format:\n- Return ONLY the fixed test code, no explanations or markdown code blocks\n- The code should be complete and runnable\n- Include all necessary imports`;\n}\n\nfunction buildUserPrompt(\n  testCode: string,\n  errorMessage: string,\n  testOutput: string | undefined,\n  originalCode: string,\n  framework: 'jest' | 'vitest',\n  attempt: number\n): string {\n  let prompt = `The following ${framework} test is failing. Fix it:\\n\\n`;\n\n  prompt += `Original function code:\\n\\`\\`\\`typescript\\n${originalCode}\\n\\`\\`\\`\\n\\n`;\n\n  prompt += `Failing test code:\\n\\`\\`\\`typescript\\n${testCode}\\n\\`\\`\\`\\n\\n`;\n\n  prompt += `Error message:\\n\\`\\`\\`\\n${errorMessage}\\n\\`\\`\\`\\n\\n`;\n\n  if (testOutput) {\n    prompt += `Test output:\\n\\`\\`\\`\\n${testOutput}\\n\\`\\`\\`\\n\\n`;\n  }\n\n  if (attempt > 1) {\n    prompt += `Note: This is fix attempt ${attempt}. Previous attempts failed. Please analyze the error more carefully.\\n\\n`;\n  }\n\n  prompt += `Fix the test code to resolve the error. Return ONLY the corrected test code, no explanations.`;\n\n  return prompt;\n}\n\n", "/**\n * Parse LLM output to extract test code\n */\n\nimport { warn } from '../utils/logger.js';\n\n/**\n * Extract test code from LLM response\n * Handles markdown code blocks, plain code, and other formats\n */\nexport function parseTestCode(response: string): string {\n  // Remove markdown code blocks if present\n  let code = response.trim();\n\n  // Check for markdown code blocks (```typescript, ```ts, ```javascript, ```js, or just ```)\n  const codeBlockRegex = /^```(?:typescript|ts|javascript|js)?\\s*\\n([\\s\\S]*?)\\n```$/;\n  const match = code.match(codeBlockRegex);\n\n  if (match) {\n    code = match[1].trim();\n  } else {\n    // Check for inline code blocks\n    const inlineCodeRegex = /```([\\s\\S]*?)```/g;\n    const inlineMatches = Array.from(code.matchAll(inlineCodeRegex));\n    if (inlineMatches.length > 0) {\n      // Use the largest code block\n      code = inlineMatches.reduce((largest, match) => {\n        return match[1].length > largest.length ? match[1] : largest;\n      }, '');\n      code = code.trim();\n    }\n  }\n\n  // Remove any leading/trailing explanation text\n  // Look for common patterns like \"Here's the test:\", \"Test code:\", etc.\n  const explanationPatterns = [\n    /^Here'?s?\\s+(?:the\\s+)?(?:test\\s+)?code:?\\s*/i,\n    /^Test\\s+code:?\\s*/i,\n    /^Generated\\s+test:?\\s*/i,\n    /^Here\\s+is\\s+the\\s+test:?\\s*/i,\n  ];\n\n  for (const pattern of explanationPatterns) {\n    if (pattern.test(code)) {\n      code = code.replace(pattern, '').trim();\n      // If there's still explanation after the code, try to extract just the code\n      const codeBlockMatch = code.match(/```[\\s\\S]*?```/);\n      if (codeBlockMatch) {\n        code = codeBlockMatch[0];\n        code = code.replace(/^```(?:typescript|ts|javascript|js)?\\s*\\n?/, '').replace(/\\n?```$/, '').trim();\n      }\n    }\n  }\n\n  // Final cleanup: remove any remaining markdown formatting\n  code = code.replace(/^```[\\w]*\\n?/, '').replace(/\\n?```$/, '').trim();\n\n  if (!code) {\n    warn('Failed to extract test code from LLM response');\n    return response; // Return original if we can't parse\n  }\n\n  return code;\n}\n\n/**\n * Validate that the parsed code looks like valid test code\n */\nexport function validateTestCodeStructure(code: string, framework: 'jest' | 'vitest'): {\n  valid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  // Check for basic test structure\n  if (!code.includes('describe') && !code.includes('it(') && !code.includes('test(')) {\n    errors.push('Missing test structure (describe/it/test)');\n  }\n\n  // Check for framework-specific imports\n  if (framework === 'jest') {\n    if (!code.includes(\"from 'jest'\") && !code.includes('from \"jest\"') && !code.includes('require(')) {\n      // Jest might use global functions, so this is just a warning\n      if (!code.includes('describe') && !code.includes('it') && !code.includes('test')) {\n        errors.push('Missing Jest test functions');\n      }\n    }\n  } else if (framework === 'vitest') {\n    if (!code.includes(\"from 'vitest'\") && !code.includes('from \"vitest\"')) {\n      errors.push('Missing Vitest import');\n    }\n  }\n\n  // Check for basic syntax (has some code, not just whitespace)\n  if (code.trim().length < 20) {\n    errors.push('Test code appears too short or empty');\n  }\n\n  // Check for common test patterns\n  if (!code.match(/(describe|it|test)\\s*\\(/)) {\n    errors.push('Missing test function calls (describe/it/test)');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n\n", "/**\n * Main test generator that orchestrates LLM calls and parsing\n */\n\nimport type { KakarotConfig } from '../types/config.js';\nimport type { TestGenerationContext, TestGenerationResult, TestFixContext } from '../types/llm.js';\nimport { createLLMProvider } from './factory.js';\nimport { buildTestGenerationPrompt } from './prompts/test-generation.js';\nimport { buildTestFixPrompt } from './prompts/test-fix.js';\nimport { parseTestCode, validateTestCodeStructure } from './parser.js';\nimport { info, warn, error, debug } from '../utils/logger.js';\n\nexport class TestGenerator {\n  private provider: ReturnType<typeof createLLMProvider>;\n  private config: Pick<KakarotConfig, 'maxFixAttempts' | 'temperature' | 'fixTemperature'>;\n\n  constructor(\n    config: Pick<\n      KakarotConfig,\n      'apiKey' | 'provider' | 'model' | 'maxTokens' | 'maxFixAttempts' | 'temperature' | 'fixTemperature'\n    >\n  ) {\n    this.provider = createLLMProvider(config);\n    this.config = {\n      maxFixAttempts: config.maxFixAttempts,\n      temperature: config.temperature,\n      fixTemperature: config.fixTemperature,\n    };\n  }\n\n  /**\n   * Generate test code for a test target\n   */\n  async generateTest(context: TestGenerationContext): Promise<TestGenerationResult> {\n    const { target, framework } = context;\n\n    info(`Generating ${framework} tests for ${target.functionName} in ${target.filePath}`);\n\n    try {\n      const messages = buildTestGenerationPrompt(context);\n      debug(`Sending test generation request to LLM for ${target.functionName}`);\n\n      const response = await this.provider.generate(messages, {\n        temperature: this.config.temperature ?? 0.2, // Lower temperature for more consistent test generation\n        maxTokens: 4000,\n      });\n\n      const testCode = parseTestCode(response.content);\n      const validation = validateTestCodeStructure(testCode, framework);\n\n      if (!validation.valid) {\n        warn(`Test code validation warnings for ${target.functionName}: ${validation.errors.join(', ')}`);\n        // Continue anyway, as some issues might be false positives\n      }\n\n      debug(`Successfully generated test code for ${target.functionName}`);\n\n      return {\n        testCode,\n        explanation: response.content !== testCode ? 'Code extracted from LLM response' : undefined,\n        usage: response.usage,\n      };\n    } catch (err) {\n      error(`Failed to generate test for ${target.functionName}: ${err instanceof Error ? err.message : String(err)}`);\n      throw err;\n    }\n  }\n\n  /**\n   * Fix a failing test by generating a corrected version\n   */\n  async fixTest(context: TestFixContext): Promise<TestGenerationResult> {\n    const { framework, attempt } = context;\n\n    info(`Fixing test (attempt ${attempt}/${this.config.maxFixAttempts})`);\n\n    try {\n      const messages = buildTestFixPrompt(context);\n      debug(`Sending test fix request to LLM (attempt ${attempt})`);\n\n      const response = await this.provider.generate(messages, {\n        temperature: this.config.fixTemperature ?? 0.1, // Very low temperature for fix attempts\n        maxTokens: 4000,\n      });\n\n      const fixedCode = parseTestCode(response.content);\n      const validation = validateTestCodeStructure(fixedCode, framework);\n\n      if (!validation.valid) {\n        warn(`Fixed test code validation warnings: ${validation.errors.join(', ')}`);\n      }\n\n      debug(`Successfully generated fixed test code (attempt ${attempt})`);\n\n      return {\n        testCode: fixedCode,\n        explanation: `Fixed test code (attempt ${attempt})`,\n        usage: response.usage,\n      };\n    } catch (err) {\n      error(`Failed to fix test (attempt ${attempt}): ${err instanceof Error ? err.message : String(err)}`);\n      throw err;\n    }\n  }\n}\n\n"],
  "mappings": "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",
  "names": ["error", "buildSystemPrompt", "buildUserPrompt", "match"]
}
